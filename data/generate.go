// generate.go creates the data.go which is required for the --init
// run option of godev. run go generate in the cmd directory to trigger
// this script

// +build ignore

package main

import (
	"crypto/md5"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"text/template"
	"time"
)

const RelativePathToDataFiles = "/data/generate"
const generatedFileWarning = `
// WARNING DO NOT MANUALLY EDIT - YOUR CHANGES WILL BE OVERRIDDEN
// MAKE CHANGES AT ~/app/data/generate AND RUN make generate TO REGENERATE
// THE FOLLOWING FILE
//
// GENERATED BY GO:GENERATE AT {{.Timestamp}}
//
// FILE GENERATED USING ~/app/data/generate.go
`

type FileContent string

type FileHash string

func main() {
	dockerfile, dockerfileHash := getFileContentsAsString("Dockerfile")
	makefile, makefileHash := getFileContentsAsString("Makefile")
	dotGitignore, dotGitignoreHash := getFileContentsAsString(".gitignore")
	dotDockerignore, dotDockerignoreHash := getFileContentsAsString(".dockerignore")
	goDotMod, goDotModHash := getFileContentsAsString("go.mod")
	mainDotGo, mainDotGoHash := getFileContentsAsString("main.go")
	if dataGoFile, err := os.Create("./data.go"); err != nil {
		panic(err)
	} else {
		defer dataGoFile.Close()
		packageTemplate.Execute(dataGoFile, struct {
			Timestamp           time.Time
			Dockerfile          FileContent
			DockerfileHash      FileHash
			Makefile            FileContent
			MakefileHash        FileHash
			DotGitignore        FileContent
			DotGitignoreHash    FileHash
			DotDockerignore     FileContent
			DotDockerignoreHash FileHash
			GoDotMod            FileContent
			GoDotModHash        FileHash
			MainDotGo           FileContent
			MainDotGoHash       FileHash
		}{
			Timestamp:           time.Now(),
			Dockerfile:          dockerfile,
			DockerfileHash:      dockerfileHash,
			Makefile:            makefile,
			MakefileHash:        makefileHash,
			DotDockerignore:     dotDockerignore,
			DotDockerignoreHash: dotDockerignoreHash,
			DotGitignore:        dotGitignore,
			DotGitignoreHash:    dotGitignoreHash,
			GoDotMod:            goDotMod,
			GoDotModHash:        goDotModHash,
			MainDotGo:           mainDotGo,
			MainDotGoHash:       mainDotGoHash,
		})
	}
}

var packageTemplate = template.Must(template.New("test").Parse(`// > data.go
` + generatedFileWarning + `
package main

// DataDockerfile defines the 'Dockerfile' contents when --init is used
// hash:{{.DockerfileHash}}
var DataDockerfile = ` + "`" + `{{.Dockerfile}}
` + "`" + `

// DataMakefile defines the 'Makefile' contents when --init is used
// hash:{{.MakefileHash}}
var DataMakefile = ` + "`" + `{{.Makefile}}
` + "`" + `

// DataDotGitignore defines the '.gitignore' contents when --init is used
// hash:{{.DotGitignoreHash}}
var DataDotGitignore = ` + "`" + `{{.DotGitignore}}
` + "`" + `

// DataDotDockerignore defines the '.dockerignore' contents when --init is used
// hash:{{.DotDockerignoreHash}}
var DataDotDockerignore = ` + "`" + `{{.DotDockerignore}}
` + "`" + `

// DataMainDotgo defines the '.dockerignore' contents when --init is used
// hash:{{.MainDotGoHash}}
var DataMainDotgo = ` + "`" + `{{.MainDotGo}}
` + "`" + `

// DataGoDotMod defines the 'go.mod' contents when --init is used
// hash:{{.GoDotModHash}}
var DataGoDotMod = ` + "`" + `{{.GoDotMod}}
` + "`" + `

` + generatedFileWarning + `
// < data.go
`))

// getFileContentsAsString exists for brevity in the main function
// by assisting in resolving the data structure - convention over configuration!
// returns the value followed by the hash
func getFileContentsAsString(filename string) (FileContent, FileHash) {
	if contents, err := ioutil.ReadFile(resolveDataFile(filename)); err != nil {
		panic(err)
	} else {
		hash := md5.Sum(contents)
		md5hash := fmt.Sprintf("%x", hash[:])
		return FileContent(string(contents)), FileHash(md5hash)
	}
}

// resolveDataFile exists to avoid listing path.Join excessively
func resolveDataFile(filename string) string {
	if cwd, err := os.Getwd(); err != nil {
		panic(err)
	} else {
		return path.Join(cwd, fmt.Sprintf("%s/%s", RelativePathToDataFiles, filename))
	}
}
